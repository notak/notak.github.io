---
title: "Service Workers Refresh Policy"
summary: "Supporting offline and making sure online users are on the latest version is hard."
layout: default
redirect_from: "/"
---

This is something that might be affecting me more because my site is being very actively developed, but something that has continued to irritate me is finding a good update policy for the static assets in a web app.

The easiest thing to do is just not bother to cache in the service worker at all - if you just ignore the fetch event you can be sure that the browser cache will work as intended, and apart from the small network overhead of a few HTTP 304 headers (not-modified), you should get a pretty efficient set up.

But this won't get you offline capability. At all. In the browser cache isn't good enough for offline - it has to be in the managed service worker cache, and it has to be fed back through the fetch event. In prinicple this is fine. You can just store requests on the way through, and then when the asset is needed again, check for it in the cache before you hit the network. A more advanced version catches the service worker register event and caches all the assets you are likely to need upfront, meaning that unvisited functionality and edge cases are dealt with cleanly. You now have a seamless offline experience, assuming your app is designed to work exclusively locally.

The first of two issues with this is data. You have the static assets, but if your app is fundamentally designed to talk to an API you don't have any data to bring them to life. One option here would be to store the REST calls in the service worker cache. Personally I'm not using a RESTful API, so that wasn't an option for me, although in general I like having a decent data layer inside the app, so using indexedDB as a storage mechanism is preferable for me. If I wasn't choosing to rather decadently ignore Safari for the moment I would probably have to look at using PouchDB as a gold-standard polyfill, but then the service worker is hardly an option for Safari either.

The second issue is updating. How do you roll a new version of your app? That is the issue I intend to deal with in the rest of the article.

My first experience of this was quite brutal - I set up the offline mode, hit refresh, and discovered I was stuck with it. There was just no way to update my code short of clearing all the local settings on the browser. That was okay for me, and obviously I tested it before I rolled it out to my unsuspecting user, but for some reason it came as a bit of surprise.

My second try was a little bit more successful. I realised that regardless of what you choose to do in your service worker, the browser will always try if it is online when you load you page to get a new version of the service worker. This means that all you need to do to recache your assets is roll a new version of the service worker. Easy! Sorry, I mean: Easy? No. The first problem is that the browser (Chrome in particular, although I've also seen Firefox do it) just loves to cache a failed response for the service worker. Have it not load just once, maybe because you forgot to start your dev server, or you hit refresh too fast while your VM was doing its thing, and you are stuck with the old service worker and no way to refresh short of clearing the browser history.

On the third attempt I went for the slightly nuclear option. I couldn't rehresh the assets in the fetch request like I wanted to because that would break offline, but that didn't mean I couldn't do a full refresh on every page load. I found that all I needed to do was pass a message from the page separately to the fetch cycle to tell the service worker to initiate the refresh. Once I'd realised that it's a seriously bad idea to pass this message from within the potentially broken library and moved it into a script block embedded direct into the html (it's only a couple of lines), it looked like I was onto something. New code was suddently available to the user, in fact it was just a couple of page refreshes away.

What? A couple? I have to hit refresh twice? What the hell? Well, if you think about it, that HTML that orders the refresh has to come from somewhere right? And that somewhere is the service worker cache. By the time your precious refresh message has kicked into action most all of the assets you are aiming to refresh will already have been fetched into the page. Still, on iteration three I'm no longer having to wipe site settings repeatedly and I don't have to push arbitrary changes to the service worker to get the browser to see changes in my stylesheet, so worrying about two refreshes seems like pure decadence. One to park until later.

Instead we'll worry about the size of the downloads. My static assets are actually pretty small. In terms of the modern mobile web almost laughably so. If I ever put ads on the site I'm sure that will change, but for the moment I'm in charge and I don't even have a jquery dependency so it's all coming in at less than 200k, most of which is static API data that I don't strictly need and certainly don't need to refresh often. On the other hand I've chosen to keep the wire size small specifically because we I'm using the app I'm often on flaky network connections where 200k could easily be 20-30 seconds. But when I fire up the cache refresh it's taking me at my word and fetching them. All of them, all of the time. 

Why is this? Well, service workers are great. They give you have full control of the whole asset-fetching process and don't attempt to second guess you at all. For some reason they don't even seem to put the filthy browser cache between you and the internet. Actually, it's possible they do but they choose not cache things that are only requested by service workers in order to save wasting space on double caching. But that means you are responsible for reimplementing cache control. This isn't incredibly difficult so long as you are also responsible for the implementation on the server side as well, but to say the least it seems pointless.

Since I am in control of the server side as well, and had bothered to implement etags even on the relatively static RESTful API chunks this was actually a pretty easy problem for me to solve. I just updated my refresh policy so that instead of blindly requesting all the assets from a list, it looked for an existing cached response for each asset, grabbed the ETAG header if there was one, and created a request for the asset which included the Etag in an IF-NONE-MATCH header. This means that any unchanged assets will simply return a 304 as they would before the service worker took over. 

Crisis averted. It's time to go back to the double-refresh what-the. In principle this shouldn't be an issue. If you are on a content site you will be refreshing the page all the time. Every time you go to a new article most likely. You might choose to implement a method where you grab in the new page from an API, push a URL and just remove the page load entirely, but unless you have crazily compelling reasons to do so you'll probably regret it. I have crazily compelling reasons to do so - the use case I have is the need to go backwards and forwards between a couple of different pages, and even if you have them open in separate tabs, that just gets to be a chore. 

This means that page refreshes or even loads don't happen very often. If you are using the homescreen integration, like my user, they may not happen at all. That means that even if I'm on the phone telling him to use a new version, the way to get that version is for him to force close the app and re-open it. Twice. This is where I'm currently at, and it kind of sucks.

So where next? Well adding a periodic refresh message in addition to the page load one will be start - that would remove the need to actually reload the page to discover updates. I would also like to detect actual changes when the service worker runs the refresh. These would either prompt the user to reload or just force a reload. The problems I have there are with the potentially clunky UI experience and with differences in service worker implementations (304s seem to have esponse.ok set to true in Firefox, but not in Chrome for example).

Overall I'm just not that happy with this. I'm taking responsibility for some stuff that I feel I shouldn't, and I'm having to add UI on the fly which users would probably expect to be part of the browser/OS chrome. Unfortunately that's pretty much where the service worker spec is at the moment. We've got the power of low-level access, but very little of the richer layering which would make it a well-used acessible tool.